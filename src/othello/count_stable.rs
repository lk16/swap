use lazy_static::lazy_static;

fn find_edge_stable(old_p: u8, old_o: u8, mut stable: u8) -> u8 {
    fn x_to_bit(x: i32) -> u8 {
        1u8.wrapping_shl(x as u32)
    }

    // Mask stable squares with remaining player squares
    stable &= old_p;

    // Empty squares
    let e = !(old_p | old_o);

    if stable == 0 || e == 0 {
        return stable;
    }

    for x in 0..8 {
        if e & x_to_bit(x) != 0 {
            let mut o = old_o;
            let mut p = old_p | x_to_bit(x); // player plays on it

            // Flip left discs
            if x > 1 {
                let mut y = x - 1;
                while y > 0 && (o & x_to_bit(y)) != 0 {
                    y -= 1;
                }
                if p & x_to_bit(y) != 0 {
                    let mut y = x - 1;
                    while y > 0 && (o & x_to_bit(y)) != 0 {
                        o ^= x_to_bit(y);
                        p ^= x_to_bit(y);
                        y -= 1;
                    }
                }
            }

            // Flip right discs
            if x < 6 {
                let mut y = x + 1;
                while y < 8 && (o & x_to_bit(y)) != 0 {
                    y += 1;
                }
                if p & x_to_bit(y) != 0 {
                    let mut y = x + 1;
                    while y < 8 && (o & x_to_bit(y)) != 0 {
                        o ^= x_to_bit(y);
                        p ^= x_to_bit(y);
                        y += 1;
                    }
                }
            }

            // Next move (player)
            stable = find_edge_stable(p, o, stable);
            if stable == 0 {
                return stable;
            }

            // Opponent's turn
            let mut p = old_p;
            let mut o = old_o | x_to_bit(x);

            // Flip left discs
            if x > 1 {
                let mut y = x - 1;
                while y > 0 && (p & x_to_bit(y)) != 0 {
                    y -= 1;
                }
                if o & x_to_bit(y) != 0 {
                    let mut y = x - 1;
                    while y > 0 && (p & x_to_bit(y)) != 0 {
                        o ^= x_to_bit(y);
                        p ^= x_to_bit(y);
                        y -= 1;
                    }
                }
            }

            // Flip right discs
            if x < 6 {
                let mut y = x + 1;
                while y < 8 && (p & x_to_bit(y)) != 0 {
                    y += 1;
                }
                if o & x_to_bit(y) != 0 {
                    let mut y = x + 1;
                    while y < 8 && (p & x_to_bit(y)) != 0 {
                        o ^= x_to_bit(y);
                        p ^= x_to_bit(y);
                        y += 1;
                    }
                }
            }

            // Next move (opponent)
            stable = find_edge_stable(p, o, stable);
            if stable == 0 {
                return stable;
            }
        }
    }

    stable
}

lazy_static! {
    static ref EDGE_STABILITY: [[u8; 256]; 256] = {
        let mut edge_stability = [[0u8; 256]; 256];

        #[allow(clippy::needless_range_loop)]
        for p in 0..256 {
            for o in 0..256 {
                if (p & o) != 0 { // illegal positions
                    edge_stability[p][o] = 0;
                } else {
                    edge_stability[p][o] = find_edge_stable(p as u8, o as u8, p as u8);
                }
            }
        }

        edge_stability
    };
}

/** conversion from an 8-bit line to the A1-A8 line */
pub const A1_A8: [u64; 256] = [
    0x0000000000000000,
    0x0000000000000001,
    0x0000000000000100,
    0x0000000000000101,
    0x0000000000010000,
    0x0000000000010001,
    0x0000000000010100,
    0x0000000000010101,
    0x0000000001000000,
    0x0000000001000001,
    0x0000000001000100,
    0x0000000001000101,
    0x0000000001010000,
    0x0000000001010001,
    0x0000000001010100,
    0x0000000001010101,
    0x0000000100000000,
    0x0000000100000001,
    0x0000000100000100,
    0x0000000100000101,
    0x0000000100010000,
    0x0000000100010001,
    0x0000000100010100,
    0x0000000100010101,
    0x0000000101000000,
    0x0000000101000001,
    0x0000000101000100,
    0x0000000101000101,
    0x0000000101010000,
    0x0000000101010001,
    0x0000000101010100,
    0x0000000101010101,
    0x0000010000000000,
    0x0000010000000001,
    0x0000010000000100,
    0x0000010000000101,
    0x0000010000010000,
    0x0000010000010001,
    0x0000010000010100,
    0x0000010000010101,
    0x0000010001000000,
    0x0000010001000001,
    0x0000010001000100,
    0x0000010001000101,
    0x0000010001010000,
    0x0000010001010001,
    0x0000010001010100,
    0x0000010001010101,
    0x0000010100000000,
    0x0000010100000001,
    0x0000010100000100,
    0x0000010100000101,
    0x0000010100010000,
    0x0000010100010001,
    0x0000010100010100,
    0x0000010100010101,
    0x0000010101000000,
    0x0000010101000001,
    0x0000010101000100,
    0x0000010101000101,
    0x0000010101010000,
    0x0000010101010001,
    0x0000010101010100,
    0x0000010101010101,
    0x0001000000000000,
    0x0001000000000001,
    0x0001000000000100,
    0x0001000000000101,
    0x0001000000010000,
    0x0001000000010001,
    0x0001000000010100,
    0x0001000000010101,
    0x0001000001000000,
    0x0001000001000001,
    0x0001000001000100,
    0x0001000001000101,
    0x0001000001010000,
    0x0001000001010001,
    0x0001000001010100,
    0x0001000001010101,
    0x0001000100000000,
    0x0001000100000001,
    0x0001000100000100,
    0x0001000100000101,
    0x0001000100010000,
    0x0001000100010001,
    0x0001000100010100,
    0x0001000100010101,
    0x0001000101000000,
    0x0001000101000001,
    0x0001000101000100,
    0x0001000101000101,
    0x0001000101010000,
    0x0001000101010001,
    0x0001000101010100,
    0x0001000101010101,
    0x0001010000000000,
    0x0001010000000001,
    0x0001010000000100,
    0x0001010000000101,
    0x0001010000010000,
    0x0001010000010001,
    0x0001010000010100,
    0x0001010000010101,
    0x0001010001000000,
    0x0001010001000001,
    0x0001010001000100,
    0x0001010001000101,
    0x0001010001010000,
    0x0001010001010001,
    0x0001010001010100,
    0x0001010001010101,
    0x0001010100000000,
    0x0001010100000001,
    0x0001010100000100,
    0x0001010100000101,
    0x0001010100010000,
    0x0001010100010001,
    0x0001010100010100,
    0x0001010100010101,
    0x0001010101000000,
    0x0001010101000001,
    0x0001010101000100,
    0x0001010101000101,
    0x0001010101010000,
    0x0001010101010001,
    0x0001010101010100,
    0x0001010101010101,
    0x0100000000000000,
    0x0100000000000001,
    0x0100000000000100,
    0x0100000000000101,
    0x0100000000010000,
    0x0100000000010001,
    0x0100000000010100,
    0x0100000000010101,
    0x0100000001000000,
    0x0100000001000001,
    0x0100000001000100,
    0x0100000001000101,
    0x0100000001010000,
    0x0100000001010001,
    0x0100000001010100,
    0x0100000001010101,
    0x0100000100000000,
    0x0100000100000001,
    0x0100000100000100,
    0x0100000100000101,
    0x0100000100010000,
    0x0100000100010001,
    0x0100000100010100,
    0x0100000100010101,
    0x0100000101000000,
    0x0100000101000001,
    0x0100000101000100,
    0x0100000101000101,
    0x0100000101010000,
    0x0100000101010001,
    0x0100000101010100,
    0x0100000101010101,
    0x0100010000000000,
    0x0100010000000001,
    0x0100010000000100,
    0x0100010000000101,
    0x0100010000010000,
    0x0100010000010001,
    0x0100010000010100,
    0x0100010000010101,
    0x0100010001000000,
    0x0100010001000001,
    0x0100010001000100,
    0x0100010001000101,
    0x0100010001010000,
    0x0100010001010001,
    0x0100010001010100,
    0x0100010001010101,
    0x0100010100000000,
    0x0100010100000001,
    0x0100010100000100,
    0x0100010100000101,
    0x0100010100010000,
    0x0100010100010001,
    0x0100010100010100,
    0x0100010100010101,
    0x0100010101000000,
    0x0100010101000001,
    0x0100010101000100,
    0x0100010101000101,
    0x0100010101010000,
    0x0100010101010001,
    0x0100010101010100,
    0x0100010101010101,
    0x0101000000000000,
    0x0101000000000001,
    0x0101000000000100,
    0x0101000000000101,
    0x0101000000010000,
    0x0101000000010001,
    0x0101000000010100,
    0x0101000000010101,
    0x0101000001000000,
    0x0101000001000001,
    0x0101000001000100,
    0x0101000001000101,
    0x0101000001010000,
    0x0101000001010001,
    0x0101000001010100,
    0x0101000001010101,
    0x0101000100000000,
    0x0101000100000001,
    0x0101000100000100,
    0x0101000100000101,
    0x0101000100010000,
    0x0101000100010001,
    0x0101000100010100,
    0x0101000100010101,
    0x0101000101000000,
    0x0101000101000001,
    0x0101000101000100,
    0x0101000101000101,
    0x0101000101010000,
    0x0101000101010001,
    0x0101000101010100,
    0x0101000101010101,
    0x0101010000000000,
    0x0101010000000001,
    0x0101010000000100,
    0x0101010000000101,
    0x0101010000010000,
    0x0101010000010001,
    0x0101010000010100,
    0x0101010000010101,
    0x0101010001000000,
    0x0101010001000001,
    0x0101010001000100,
    0x0101010001000101,
    0x0101010001010000,
    0x0101010001010001,
    0x0101010001010100,
    0x0101010001010101,
    0x0101010100000000,
    0x0101010100000001,
    0x0101010100000100,
    0x0101010100000101,
    0x0101010100010000,
    0x0101010100010001,
    0x0101010100010100,
    0x0101010100010101,
    0x0101010101000000,
    0x0101010101000001,
    0x0101010101000100,
    0x0101010101000101,
    0x0101010101010000,
    0x0101010101010001,
    0x0101010101010100,
    0x0101010101010101,
];

/** conversion from an 8-bit line to the H1-H8 line */
pub const H1_H8: [u64; 256] = [
    0x0000000000000000,
    0x0000000000000080,
    0x0000000000008000,
    0x0000000000008080,
    0x0000000000800000,
    0x0000000000800080,
    0x0000000000808000,
    0x0000000000808080,
    0x0000000080000000,
    0x0000000080000080,
    0x0000000080008000,
    0x0000000080008080,
    0x0000000080800000,
    0x0000000080800080,
    0x0000000080808000,
    0x0000000080808080,
    0x0000008000000000,
    0x0000008000000080,
    0x0000008000008000,
    0x0000008000008080,
    0x0000008000800000,
    0x0000008000800080,
    0x0000008000808000,
    0x0000008000808080,
    0x0000008080000000,
    0x0000008080000080,
    0x0000008080008000,
    0x0000008080008080,
    0x0000008080800000,
    0x0000008080800080,
    0x0000008080808000,
    0x0000008080808080,
    0x0000800000000000,
    0x0000800000000080,
    0x0000800000008000,
    0x0000800000008080,
    0x0000800000800000,
    0x0000800000800080,
    0x0000800000808000,
    0x0000800000808080,
    0x0000800080000000,
    0x0000800080000080,
    0x0000800080008000,
    0x0000800080008080,
    0x0000800080800000,
    0x0000800080800080,
    0x0000800080808000,
    0x0000800080808080,
    0x0000808000000000,
    0x0000808000000080,
    0x0000808000008000,
    0x0000808000008080,
    0x0000808000800000,
    0x0000808000800080,
    0x0000808000808000,
    0x0000808000808080,
    0x0000808080000000,
    0x0000808080000080,
    0x0000808080008000,
    0x0000808080008080,
    0x0000808080800000,
    0x0000808080800080,
    0x0000808080808000,
    0x0000808080808080,
    0x0080000000000000,
    0x0080000000000080,
    0x0080000000008000,
    0x0080000000008080,
    0x0080000000800000,
    0x0080000000800080,
    0x0080000000808000,
    0x0080000000808080,
    0x0080000080000000,
    0x0080000080000080,
    0x0080000080008000,
    0x0080000080008080,
    0x0080000080800000,
    0x0080000080800080,
    0x0080000080808000,
    0x0080000080808080,
    0x0080008000000000,
    0x0080008000000080,
    0x0080008000008000,
    0x0080008000008080,
    0x0080008000800000,
    0x0080008000800080,
    0x0080008000808000,
    0x0080008000808080,
    0x0080008080000000,
    0x0080008080000080,
    0x0080008080008000,
    0x0080008080008080,
    0x0080008080800000,
    0x0080008080800080,
    0x0080008080808000,
    0x0080008080808080,
    0x0080800000000000,
    0x0080800000000080,
    0x0080800000008000,
    0x0080800000008080,
    0x0080800000800000,
    0x0080800000800080,
    0x0080800000808000,
    0x0080800000808080,
    0x0080800080000000,
    0x0080800080000080,
    0x0080800080008000,
    0x0080800080008080,
    0x0080800080800000,
    0x0080800080800080,
    0x0080800080808000,
    0x0080800080808080,
    0x0080808000000000,
    0x0080808000000080,
    0x0080808000008000,
    0x0080808000008080,
    0x0080808000800000,
    0x0080808000800080,
    0x0080808000808000,
    0x0080808000808080,
    0x0080808080000000,
    0x0080808080000080,
    0x0080808080008000,
    0x0080808080008080,
    0x0080808080800000,
    0x0080808080800080,
    0x0080808080808000,
    0x0080808080808080,
    0x8000000000000000,
    0x8000000000000080,
    0x8000000000008000,
    0x8000000000008080,
    0x8000000000800000,
    0x8000000000800080,
    0x8000000000808000,
    0x8000000000808080,
    0x8000000080000000,
    0x8000000080000080,
    0x8000000080008000,
    0x8000000080008080,
    0x8000000080800000,
    0x8000000080800080,
    0x8000000080808000,
    0x8000000080808080,
    0x8000008000000000,
    0x8000008000000080,
    0x8000008000008000,
    0x8000008000008080,
    0x8000008000800000,
    0x8000008000800080,
    0x8000008000808000,
    0x8000008000808080,
    0x8000008080000000,
    0x8000008080000080,
    0x8000008080008000,
    0x8000008080008080,
    0x8000008080800000,
    0x8000008080800080,
    0x8000008080808000,
    0x8000008080808080,
    0x8000800000000000,
    0x8000800000000080,
    0x8000800000008000,
    0x8000800000008080,
    0x8000800000800000,
    0x8000800000800080,
    0x8000800000808000,
    0x8000800000808080,
    0x8000800080000000,
    0x8000800080000080,
    0x8000800080008000,
    0x8000800080008080,
    0x8000800080800000,
    0x8000800080800080,
    0x8000800080808000,
    0x8000800080808080,
    0x8000808000000000,
    0x8000808000000080,
    0x8000808000008000,
    0x8000808000008080,
    0x8000808000800000,
    0x8000808000800080,
    0x8000808000808000,
    0x8000808000808080,
    0x8000808080000000,
    0x8000808080000080,
    0x8000808080008000,
    0x8000808080008080,
    0x8000808080800000,
    0x8000808080800080,
    0x8000808080808000,
    0x8000808080808080,
    0x8080000000000000,
    0x8080000000000080,
    0x8080000000008000,
    0x8080000000008080,
    0x8080000000800000,
    0x8080000000800080,
    0x8080000000808000,
    0x8080000000808080,
    0x8080000080000000,
    0x8080000080000080,
    0x8080000080008000,
    0x8080000080008080,
    0x8080000080800000,
    0x8080000080800080,
    0x8080000080808000,
    0x8080000080808080,
    0x8080008000000000,
    0x8080008000000080,
    0x8080008000008000,
    0x8080008000008080,
    0x8080008000800000,
    0x8080008000800080,
    0x8080008000808000,
    0x8080008000808080,
    0x8080008080000000,
    0x8080008080000080,
    0x8080008080008000,
    0x8080008080008080,
    0x8080008080800000,
    0x8080008080800080,
    0x8080008080808000,
    0x8080008080808080,
    0x8080800000000000,
    0x8080800000000080,
    0x8080800000008000,
    0x8080800000008080,
    0x8080800000800000,
    0x8080800000800080,
    0x8080800000808000,
    0x8080800000808080,
    0x8080800080000000,
    0x8080800080000080,
    0x8080800080008000,
    0x8080800080008080,
    0x8080800080800000,
    0x8080800080800080,
    0x8080800080808000,
    0x8080800080808080,
    0x8080808000000000,
    0x8080808000000080,
    0x8080808000008000,
    0x8080808000008080,
    0x8080808000800000,
    0x8080808000800080,
    0x8080808000808000,
    0x8080808000808080,
    0x8080808080000000,
    0x8080808080000080,
    0x8080808080008000,
    0x8080808080008080,
    0x8080808080800000,
    0x8080808080800080,
    0x8080808080808000,
    0x8080808080808080,
];

fn get_stable(player: u64, opponent: u64) -> u64 {
    let disc = player | opponent;
    let central_mask = player & 0x007e7e7e7e7e7e00;
    let full_h = get_full_lines(disc, 1);
    let full_v = get_full_lines(disc, 8);
    let full_d7 = get_full_lines(disc, 7);
    let full_d9 = get_full_lines(disc, 9);

    // compute the exact stable edges (from precomputed tables)
    let mut new_stable = get_stable_edge(player, opponent);

    // add full lines
    new_stable |= full_h & full_v & full_d7 & full_d9 & central_mask;

    // now compute the other stable discs (ie discs touching another stable disc in each flipping direction).
    let mut stable = 0;
    while (new_stable & !stable) != 0 {
        stable |= new_stable;
        let stable_h = (stable >> 1) | (stable << 1) | full_h;
        let stable_v = (stable >> 8) | (stable << 8) | full_v;
        let stable_d7 = (stable >> 7) | (stable << 7) | full_d7;
        let stable_d9 = (stable >> 9) | (stable << 9) | full_d9;
        new_stable = stable_h & stable_v & stable_d7 & stable_d9 & central_mask;
    }

    stable
}

/// Count the number of stable discs for the given player.
///
/// Like count_stable() in Edax
pub fn count_stable(player: u64, opponent: u64) -> i32 {
    get_stable(player, opponent).count_ones() as i32
}

fn get_full_lines(line: u64, dir: i32) -> u64 {
    const EDGE: u64 = 0xff818181818181ff;
    let dir2: i32 = dir << 1;
    let dir4: i32 = dir << 2;

    let mut full_l = line & (EDGE | (line >> dir));
    let mut full_r = line & (EDGE | (line << dir));
    let mut edge_l = EDGE | (EDGE >> dir);
    let mut edge_r = EDGE | (EDGE << dir);
    full_l &= edge_l | (full_l >> dir2);
    full_r &= edge_r | (full_r << dir2);
    edge_l |= edge_l >> dir2;
    edge_r |= edge_r << dir2;
    full_l &= edge_l | (full_l >> dir4);
    full_r &= edge_r | (full_r << dir4);

    full_r & full_l
}

pub fn get_stable_edge(player: u64, opponent: u64) -> u64 {
    EDGE_STABILITY[(player & 0xff) as usize][(opponent & 0xff) as usize] as u64
        | (EDGE_STABILITY[(player >> 56) as usize][(opponent >> 56) as usize] as u64) << 56
        | A1_A8[EDGE_STABILITY[pack_a1_h8(player)][pack_a1_h8(opponent)] as usize]
        | H1_H8[EDGE_STABILITY[pack_h1_h8(player)][pack_h1_h8(opponent)] as usize]
}

fn pack_a1_h8(x: u64) -> usize {
    let packed = (x & 0x0101010101010101).wrapping_mul(0x0102040810204080) >> 56;
    packed as usize
}

fn pack_h1_h8(x: u64) -> usize {
    let packed = (x & 0x8080808080808080).wrapping_mul(0x0002040810204081) >> 56;
    packed as usize
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::othello::position::Position;

    #[test]
    fn test_stable_discs_with_moves() {
        for i in 0..1000 {
            // Generate random board with 40-64 discs
            let num_discs = 40 + i % 25;
            let position = Position::new_random_with_discs(num_discs);

            // Get stable discs for current position
            let stable = get_stable(position.player, position.opponent);

            // Compute which discs can be flipped by any move
            let mut all_flipped = 0u64;
            for move_ in position.iter_move_indices() {
                all_flipped |= position.get_flipped(move_);
            }

            // Compute which discs can be flipped by opponent
            let mut passed = position;
            passed.pass();
            for move_ in passed.iter_move_indices() {
                all_flipped |= passed.get_flipped(move_);
            }

            // Verify that no stable disc gets flipped
            assert_eq!(
                stable & all_flipped,
                0,
                "Stable disc was flipped! Board:\n{}\nStable: {:016x}\nFlipped: {:016x}",
                position,
                stable,
                all_flipped
            );
        }
    }
}
